pub mod box_gen;
pub mod box_layout;
pub mod box_model;
pub mod layout_box;

use layout_box::LayoutBox;
use style::render_tree::RenderNodeRef;
use style::value_processing::{Property, Value};
use style::values::display::Display;
use style::values::float::Float;
use style::values::position::Position;

pub use box_gen::build_layout_tree;
pub use box_layout::layout;
pub use box_layout::ContainingBlock;

/// Detect if a node is a text node
pub fn is_text_node(root: &RenderNodeRef) -> bool {
    root.borrow().node.is::<dom::text::Text>()
}

/// Detect if an element is a block-level element
pub fn is_block_level_element(root: &RenderNodeRef) -> bool {
    let render_node = root.borrow();
    let display_value = render_node.get_style(&Property::Display);
    let display = display_value.inner();

    match display {
        Value::Display(Display::Block)
        | Value::Display(Display::ListItem)
        | Value::Display(Display::Table) => true,
        _ => false,
    }
}

/// Detect if a box is a block container box
///
/// There are 2 cases that a box is considered as a block container:
/// 1. It's a block-level box & not table box & not principal block of
/// a replaced element
/// 2. It's generated by an element with display: block, list-item, inline-block
// TODO: Detect if the box is a block-level box too
pub fn is_block_container_box(layout_box: &LayoutBox) -> bool {
    let render_node = layout_box.render_node.borrow();
    let display_value = render_node.get_style(&Property::Display);
    let display = display_value.inner();

    match display {
        Value::Display(Display::Block)
        | Value::Display(Display::Inline)
        | Value::Display(Display::InlineBlock) => true,
        _ => false,
    }
}

/// Detect if an element is a inline-level element
pub fn is_inline_level_element(root: &RenderNodeRef) -> bool {
    let render_node = root.borrow();
    let display_value = render_node.get_style(&Property::Display);
    let display = display_value.inner();

    match display {
        Value::Display(Display::Inline)
        | Value::Display(Display::InlineTable)
        | Value::Display(Display::InlineBlock) => true,
        _ => false,
    }
}

/// Detect if an element is a non-replaced element
pub fn is_non_replaced_element(root: &RenderNodeRef) -> bool {
    let render_node = root.borrow();

    if let Some(element) = render_node.node.borrow().as_element() {
        return match element.tag_name().as_ref() {
            "img" | "image" | "canvas" | "video" | "audio" => false,
            _ => true,
        };
    }

    false
}

/// Detect if an element is a floated element
pub fn is_float_element(root: &RenderNodeRef) -> bool {
    let render_node = root.borrow();
    let float_value = render_node.get_style(&Property::Float);
    let float = float_value.inner();

    match float {
        Value::Float(Float::None) => false,
        _ => true,
    }
}

/// Detect if an element is an absolutely positioned element
pub fn is_absolutely_positioned(root: &RenderNodeRef) -> bool {
    let render_node = root.borrow();
    let position_value = render_node.get_style(&Property::Position);
    let position = position_value.inner();

    match position {
        Value::Position(Position::Absolute) => true,
        Value::Position(Position::Fixed) => true,
        _ => false,
    }
}

/// Detect if an element is an inline-block element
pub fn is_inline_block(root: &RenderNodeRef) -> bool {
    let render_node = root.borrow();
    let display_value = render_node.get_style(&Property::Display);
    let display = display_value.inner();

    match display {
        Value::Display(Display::InlineBlock) => true,
        _ => false,
    }
}

pub fn is_in_normal_flow(layout_box: &LayoutBox) -> bool {
    layout_box.parent_formatting_context.is_some()
        || layout_box.render_node.borrow().parent_render_node.is_none()
}

#[cfg(test)]
mod test_utils {
    use super::layout_box::LayoutBox;

    pub fn print_layout_tree(root: &LayoutBox, level: usize) {
        let child_nodes = &root.children;
        println!(
            "{}{:#?}({:#?})(x: {} | y: {} | width: {} | height: {})",
            "    ".repeat(level),
            root.box_type,
            root.render_node.borrow().node,
            root.dimensions.content.x,
            root.dimensions.content.y,
            root.dimensions.content.width,
            root.dimensions.content.height
        );
        for node in child_nodes {
            print_layout_tree(node, level + 1);
        }
    }
}
